<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://thirdsense3.github.io/tag/acmicpc/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://thirdsense3.github.io/" rel="alternate" type="text/html" />
  <updated>2021-05-03T13:09:18+00:00</updated>
  <id>https://thirdsense3.github.io/tag/acmicpc/feed.xml</id>

  
  
  

  
    <title type="html">To Be Programmer | </title>
  

  
    <subtitle>프로그래머가 되기 위한 나의 노력을 담은 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">1965번 상자넣기 - Silver 2</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_1965" rel="alternate" type="text/html" title="1965번 상자넣기 - Silver 2" />
      <published>2021-04-29T15:32:00+00:00</published>
      <updated>2021-04-29T15:32:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_1965</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_1965">&lt;h2 id=&quot;상자-넣기-1965번&quot;&gt;상자 넣기 1965번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다. 예를 들어 앞에서부터 순서대로 크기가 (1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.&lt;/p&gt;

  &lt;p&gt;상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;파일의 첫 번째 줄은 상자의 개수 n (1 ≤ n ≤ 1000)을 나타낸다. 두 번째 줄에는 각 상자의 크기가 순서대로 주어진다. 상자의 크기는 1,000을 넘지 않는 자연수이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 한 줄에 넣을 수 있는 최대의 상자 개수를 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;LIS(Longest Increasing Subswquence) 알고리즘 활용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LIS 알고리즘으로 가장 긴 증가 수열을 구하는 알고리즘을 활용했다.&lt;/p&gt;

&lt;p&gt;LIS  알고리즘은 3가지로 나눌 수 있는데, 주어진 배열의 길이가 10만이하의 경우, 브루트포스, DP를 활용한 LIS 알고리즘을 설계 할 수 있고,&lt;/p&gt;

&lt;p&gt;10만 이상의 경우, 이분탐색을 활용한 LIS 알고리즘 구현이 가능하다.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/a8aa3880459a7e196697dadd50b9032f.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">상자 넣기 1965번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">9252번 LCS2 - Gold 5</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_9252" rel="alternate" type="text/html" title="9252번 LCS2 - Gold 5" />
      <published>2021-04-28T21:46:00+00:00</published>
      <updated>2021-04-28T21:46:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_9252</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_9252">&lt;h2 id=&quot;lcs2-9252번&quot;&gt;LCS2 9252번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.&lt;/p&gt;

  &lt;p&gt;예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를, 둘째 줄에 LCS를 출력한다.&lt;/p&gt;

  &lt;p&gt;LCS가 여러 가지인 경우에는 아무거나 출력하고, LCS의 길이가 0인 경우에는 둘째 줄을 출력하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 수열중의 부분 수열을 찾아내는 문제다.&lt;/p&gt;

  &lt;p&gt;두 수열을 DP의 인덱스로 잡고 표를 그려보면&lt;/p&gt;

  &lt;p&gt;두 부분수열이 공통부분이 생겼을때,&lt;/p&gt;

  &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;두 부분수열이 같지 않을 때.&lt;/p&gt;

  &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이를 조합하여 점화식을 작성하면 다음과 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/5205d11c3aa1cc92e8bfb4d4b9df09f3.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">LCS2 9252번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">2225번 합분해 - Gold 5</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_2225" rel="alternate" type="text/html" title="2225번 합분해 - Gold 5" />
      <published>2021-04-28T21:46:00+00:00</published>
      <updated>2021-04-28T21:46:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_2225</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_2225">&lt;h2 id=&quot;합분해-2225번&quot;&gt;합분해 2225번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;128MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.&lt;/p&gt;

  &lt;p&gt;덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DP를 활용한 점화식 문제&lt;/p&gt;

  &lt;p&gt;식을 표현하면  &lt;img src=&quot;./assets/built/images/acmicpc_num_2225.png&quot; alt=&quot;acmicpc_num_2225&quot; /&gt; 으로 표현가능하다.&lt;/p&gt;

  &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// dp[n-1][k] = dp[0][k-1] + ... + dp[n-1][k] 이므로
// dp[n][k] = dp[n-1][k] + dp[n][k-1] 로 표현가능하다.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;따라서 DP 계산하면서 위와 왼쪽 값을 계속해서 더해주면 O(n^2)으로 구현이 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/49602638d80a6a2eaabecdc786f75da9.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">합분해 2225번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">5213번 과외맨 - Gold 3</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_5213" rel="alternate" type="text/html" title="5213번 과외맨 - Gold 3" />
      <published>2021-04-28T21:46:00+00:00</published>
      <updated>2021-04-28T21:46:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_5213</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_5213">&lt;h2 id=&quot;과외맨-5213번&quot;&gt;과외맨 5213번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;과외맨은 평소에 서강대학교 학생 이민혁으로 위장하고 있는 한국의 대표적인 영웅이다. 그는 슈퍼 히어로가 너무 미국에 집중되어 있는 현실을 안타까워했고, 그의 절친한 친구인 스파이더맨과 아이언맨에게 한국으로 와서 같이 영웅 활동을 하자는 제안을 했으나 거절당했다.&lt;/p&gt;

  &lt;p&gt;얼마 전, 오랜 잠에서 깨어난 고대 마야인들이 과외맨이 수업을 듣는 동안 과외 노트를 훔쳐갔다. 과외맨은 빼앗긴 노트를 찾아오기 위해 인천 공항으로 가서 과테말라로 가는 비행기를 탔다.&lt;/p&gt;

  &lt;p&gt;일단 언어가 통하지 않기 때문에, 과외맨은 자신의 특기를 살려서 일주일간 과테말라에서 스페인어를 과외 받았다.&lt;/p&gt;

  &lt;p&gt;오랜 고서에 의하면, 고대 마야인은 하늘을 날아다니는 재주가 있었다고 한다. 과외맨은 매일 밤 하늘을 바라보며 마야인들의 흔적을 찾으려고 애를 썼다.&lt;/p&gt;

  &lt;p&gt;그렇게 한 달이 지났을까… 한국에선 이민혁 실종 사건이 연일 대서특필 되고 있고, 사람들은 사라진 과외맨을 찾으며 시청 광장에서 촛불 집회를 했다. 과외맨도 이런 사실에 안타까움을 느꼈다. 하지만, 과외 노트 없는 과외맨은 평범한 대학생과 같기 때문에 아직 돌아갈 수 없었다.&lt;/p&gt;

  &lt;p&gt;과외 노트의 단서는 뜻하지 않게 스페인어 과외를 받던 중에 알게 되었다. 과외맨의 과외 선생님이 주말을 이용해서 등산을 하던 사이에 고대 마야의 사원으로 보이는 것을 발견했고, 민혁이에게 과외 노트가 거기에 있는 것 같다고 알려주었다.&lt;/p&gt;

  &lt;p&gt;과외맨은 즉시 과외 노트를 찾으러 고대 마야의 사원으로 여행을 떠났다.&lt;/p&gt;

  &lt;p&gt;고대 마야의 사원의 입구로 들어간 과외맨은 매우 놀랐다. 바로 과외 노트가 자신의 눈 앞에 있는 것 이었다. 과외맨은 이적의 다행이다를 부르면서 과외 노트를 집으려고 했지만, 그것은 노트의 홀로그램이었다. 이어서 고대 마야인의 목소리가 사원을 가득 채우기 시작했다. 하지만, 고대 마야인은 스페인어를 사용하지 않았다. 과외맨은 닥터후에게 전화를 걸어서 자신에게 타디스의 번역 프로토콜을 제공해 줄 수 있는지를 물어 보았다. 닥터는 흔쾌히 요청을 받아들였고, 민혁이는 마야인의 메시지를 듣기 위해 밖으로 나갔다가 다시 들어왔다.&lt;/p&gt;

  &lt;p&gt;“하하하. 과외 노트를 돌려 받고 싶나? 그럼 여기로 와서 가져가 보시지. 하하하하”&lt;/p&gt;

  &lt;p&gt;과외맨의 과외 노트는 입구의 반대편에 있고, 그 사이에는 절벽이 있었다. 갑자기 하늘에서 거대한 도미노 타일이 떨어졌고, 그 사이를 연결하는 다리를 만들었다.&lt;/p&gt;

  &lt;p&gt;도미노 타일은 두 조각으로 나누어져 있었고, 각 조각은 정사각형이다. 조각에는 1과 6사이의 숫자가 써져 있다.&lt;/p&gt;

  &lt;p&gt;타일은 N줄로 놓여져 있고, 홀수 줄에는 N개의 타일이, 짝수 줄에는 N-1개의 타일이 놓여져 있다. 아래 그림은 (N=5)일 때 타일이 놓여져 있는 형태이다.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;./assets/built/images/acmicpc_num_5213.png&quot; alt=&quot;acmicpc_num_5213&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;한 타일에서 다른 타일로 넘어가려면, 두 타일이 인접해야 한다. 또, 같은 변을 공유하는 조각에 쓰여 있는 숫자가 같아야 한다.&lt;/p&gt;

  &lt;p&gt;과외맨은 반대편으로 넘어가기 위해서 첫 줄의 가장 첫 타일에서 마지막 줄의 가장 마지막 타일로 이동하는 가장 짧은 경로를 찾으려고 한다.&lt;/p&gt;

  &lt;p&gt;타일은 row-major order에 의해서 번호가 매겨져 있으며, 첫 번째 줄의 첫 타일의 번호는 1, 마지막 타일의 번호는 N이다. 두 번째 줄에서 첫 타일의 번호는 N+1이고, 마지막 타일의 번호는 2*N-1이다.&lt;/p&gt;

  &lt;p&gt;첫 줄의 첫 타일로만 과외맨이 들어갈 수 있고, 마지막 줄의 마지막 타일위에 과외 노트가 놓여져 있다.&lt;/p&gt;

  &lt;p&gt;마지막 줄의 마지막 타일로 이동할 수 없는 경우가 존재할 수 있다. 이 경우에는 번호가 가장 큰 타일로 이동하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 N이 주어진다. (1 ≤ N ≤ 500) 다음 줄부터 N*N-N/2줄(/는 정수 나눗셈이다)에는 두 양의 Ai와 Bi가 주어진다. 
(1 ≤ Ai, Bi ≤ 6, 1 ≤ i ≤ N * N - N / 2) 타일 i의 왼쪽에 쓰여 있는 숫자는 Ai, 오른쪽에 쓰여 있는 숫자는 Bi이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 가장 짧은 경로의 길이 (타일의 개수)를 출력한다. 둘째 줄에는 경로 상의 타일의 번호를 공백으로 구분하여 순서대로 출력한다. 만약, 가장 짧은 경로가 여러 가지라면, 아무거나 출력하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;BFS를 활용한 구현문제.&lt;/p&gt;

  &lt;p&gt;타일에 속한 값이 왼쪽, 오른쪽 두개가 있으므로 배열을 최대 [500][1000]까지 잡았다.
타일의번호 또한 최대 500*500-50/2까지 존재하므로 backtracking할 배열 back배열과 타일의 번호에따라서 몇번째 줄인지를 저장해놓은 idxline배열, 방문 인덱스를 저장할 배열을 최대 26만까지 넉넉하게 잡았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/b4e412e4e49378508f3d7eb0613ea6f9.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">과외맨 5213번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">2529번 부등호 - Silver 2</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_2529" rel="alternate" type="text/html" title="2529번 부등호 - Silver 2" />
      <published>2021-04-19T21:14:00+00:00</published>
      <updated>2021-04-19T21:14:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_2529</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_2529">&lt;h2 id=&quot;부등호-2529번&quot;&gt;부등호 2529번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;두 종류의 부등호 기호 ‘&amp;lt;’와 ‘&amp;gt;’가 k개 나열된 순서열  A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자.&lt;/p&gt;

  &lt;p&gt;A =&amp;gt;  &amp;lt; &amp;lt; &amp;lt; &amp;gt; &amp;lt; &amp;lt; &amp;gt; &amp;lt; &amp;gt;&lt;/p&gt;

  &lt;p&gt;부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를 만족시키는 한 예이다.&lt;/p&gt;

  &lt;p&gt;3 &amp;lt; 4 &amp;lt; 5 &amp;lt; 6 &amp;gt; 1 &amp;lt; 2 &amp;lt; 8 &amp;gt; 7 &amp;lt; 9 &amp;gt; 0&lt;/p&gt;

  &lt;p&gt;이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다. 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다.&lt;/p&gt;

  &lt;p&gt;5 &amp;lt; 6 &amp;lt; 8 &amp;lt; 9 &amp;gt; 0 &amp;lt; 2 &amp;lt; 3 &amp;gt; 1 &amp;lt; 7 &amp;gt; 4&lt;/p&gt;

  &lt;p&gt;여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다. 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 선택된 숫자는 모두 달라야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다. 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 2 ≤ k ≤ 9 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 문제는 백트래킹을 이용한 브루트 포스를 이용했다.&lt;/p&gt;

  &lt;p&gt;재귀를 이용한 백트래킹을 구현하여, 만약 i+1번째에 올 수 있는 숫자가 없다면, i번째 인덱스로 백트래킹하여, 다시 다른 값을 넣고 i+1번째 숫자를 계산하는 식으로 백트래킹, 브루트포스를 구현했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/1718b71fd02134286f5639a59bad4a61.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">부등호 2529번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">1931번 회의실 배정 - Silver 2</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_1931" rel="alternate" type="text/html" title="1931번 회의실 배정 - Silver 2" />
      <published>2021-04-19T21:14:00+00:00</published>
      <updated>2021-04-19T21:14:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_1931</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_1931">&lt;h2 id=&quot;회의실-배정-1931번&quot;&gt;회의실 배정 1931번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;2초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;128MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’&lt;/p&gt;

&lt;p&gt;설명&lt;/p&gt;

&lt;p&gt;’’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그리디 알고리즘, 정렬을 이용하면 쉽게 풀 수 있다.&lt;/p&gt;

  &lt;p&gt;보통 이런 문제를 접해보지 않았으면, 시작시간으로 그리디 알고리즘을 적용하기 쉬운데, 그러면 일찍 시작하고 늦게 끝나는 경우때문에 많은 회의를 잡을 수 없다.&lt;/p&gt;

  &lt;p&gt;그래서 끝나는 시간으로 정렬하고 일찍 끝나는 회의를 회의실에 배정하도록 알고리즘을 짜면 쉽게 풀 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/a49dfa6e36cbf99d798a06194dc3ae2d.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">회의실 배정 1931번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">11047번 동전 0 - Silver 2</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_11047" rel="alternate" type="text/html" title="11047번 동전 0 - Silver 2" />
      <published>2021-04-19T21:14:00+00:00</published>
      <updated>2021-04-19T21:14:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_11047</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_11047">&lt;h2 id=&quot;동전-0-11047번&quot;&gt;동전 0 11047번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.&lt;/p&gt;

  &lt;p&gt;동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’&lt;/p&gt;

&lt;p&gt;Input
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 N과 K가 주어진다. (1  ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)&lt;/p&gt;

  &lt;p&gt;둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
설명
‘’’&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그리디 알고리즘을 이용한 가장 기초 문제.&lt;/p&gt;

  &lt;p&gt;그리디 알고리즘, 말 그대로 조건에 알맞은 가장 큰값부터 차례대로 넣으면서 개수를 카운트한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&quot;https://gist.github.com/Thirdsense3/cec5f89a7bf8ed4ea271fa1bc8394dde.js&quot;&gt;&lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">동전 0 11047번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">14503번 로봇 청소기 - Gold 5</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_14503" rel="alternate" type="text/html" title="14503번 로봇 청소기 - Gold 5" />
      <published>2021-04-17T12:15:00+00:00</published>
      <updated>2021-04-17T12:15:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_14503</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_14503">&lt;h2 id=&quot;로봇-청소기-14503번&quot;&gt;로봇 청소기 14503번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;2초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;512MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.
로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;로봇 청소기는 다음과 같이 작동한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;현재 위치를 청소한다.&lt;/li&gt;
    &lt;li&gt;현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
 a.왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
 b.왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
 c.네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
 d.네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50) 
둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.
셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.
로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;로봇 청소기가 청소하는 칸의 개수를 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;삼성 SW 역량 테스트 기출 문제로 간단한 구현문제에 속한다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;set&amp;gt;

using namespace std;

int n, m;
int r, c;
int d; // 0:북 1:동 2:남 3:서
bool arr[52][52];
int dirx[] = { -1,0,1,0 }; // 북 동 남 서 (북쪽기준)
int diry[] = { 0,1,0,-1 };
bool check[52][52];
bool turnoff;
int answer;

struct pos
{
	int x;
	int y;
	int dir;
};

void clean(int x, int y, int dir) {
	stack&amp;lt;pos&amp;gt; st;
	st.push({ x,y,dir });

	while (!st.empty()) {
		int curx = st.top().x;
		int cury = st.top().y;
		int curdir = st.top().dir;
		st.pop();

		check[curx][cury] = true;
		int cnt = 0;
		answer++;

		while (true) {

			int leftx = curx + dirx[(3 + curdir) % 4];
			int lefty = cury + diry[(3 + curdir) % 4];

			if (!check[leftx][lefty] &amp;amp;&amp;amp; !arr[leftx][lefty]) {
				st.push({ leftx,lefty,(3 + curdir) % 4 });
				break;
			}
			else if (cnt == 4) {
				int backx = curx + dirx[(2 + curdir) % 4];
				int backy = cury + diry[(2 + curdir) % 4];

				if (arr[backx][backy]) {
					turnoff = true;
					break;
				}
				else {
					curx = backx;
					cury = backy;
					cnt = 0;
					continue;
				}
			}
			else if (arr[leftx][lefty]) {
				curdir = (3 + curdir) % 4;
				cnt++;
				continue;
			}
			else if (check[leftx][lefty] &amp;amp;&amp;amp; !arr[leftx][lefty]) {
				curdir = (3 + curdir) % 4;
				cnt++;
			}
		}

	}

}

int main() {
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;

	for (int i = 1; i &amp;lt;= n; i++) {
		for (int j = 1; j &amp;lt;= m; j++) {
			cin &amp;gt;&amp;gt; arr[i][j];
			check[i][j] = arr[i][j];
		}
	}

	for (int i = 0; i &amp;lt; 52; i++) {
		arr[i][0] = true;
		arr[i][m + 1] = true;
		arr[0][i] = true;
		arr[n + 1][i] = true;
		check[i][0] = true;
		check[i][m + 1] = true;
		check[0][i] = true;
		check[n + 1][i] = true;
	}

	clean(r + 1, c + 1, d);

	cout &amp;lt;&amp;lt; answer;

}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Thirdsense3/350c8cb0e0c1be9f76e4c7e8d1cc543a.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">로봇 청소기 14503번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">1520번 내리막 길 - Gold 4</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_1520" rel="alternate" type="text/html" title="1520번 내리막 길 - Gold 4" />
      <published>2021-04-16T19:44:00+00:00</published>
      <updated>2021-04-16T19:44:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_1520</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_1520">&lt;h2 id=&quot;내리막-길-1520번&quot;&gt;내리막 길 1520번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;2초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;128MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.
현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다.
M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;최근에 풀었던 문자열 문제와 같은 부류의 문제다.&lt;/p&gt;

&lt;p&gt;dp와 dfs를 이용해서 한번 갔던 경로는 dp배열에 저장해서 중복 체크를 방지했다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;set&amp;gt;

using namespace std;

int n, m;
int arr[501][501];
int dp[501][501];
int dirx[] = { 0,0,1,-1 };
int diry[] = { 1,-1,0,0 };
int answer;

int dfs(int x, int y) {
	if (dp[x][y] != -1) {
		return dp[x][y];
	}

	if (x == n - 1 &amp;amp;&amp;amp; y == m - 1) {
		return 1;
	}

	dp[x][y] = 0;

	for (int i = 0; i &amp;lt; 4; i++) {
		int gox = x + dirx[i];
		int goy = y + diry[i];

		if (gox &amp;gt;= 0 &amp;amp;&amp;amp; gox &amp;lt; n &amp;amp;&amp;amp; goy &amp;gt;= 0 &amp;amp;&amp;amp; goy &amp;lt; m &amp;amp;&amp;amp; arr[gox][goy] &amp;lt; arr[x][y]) {
			dp[x][y] += dfs(gox, goy);
		}
	}

	return dp[x][y];
}


int main() {
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

	for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; m; j++) {
			cin &amp;gt;&amp;gt; arr[i][j];
		}
	}

	memset(dp, -1, sizeof(dp));

	answer = dfs(0, 0);

	cout &amp;lt;&amp;lt; answer;

}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Thirdsense3/94d1ce02a72cee981eb3fb2511716f6d.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">내리막 길 1520번</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">5419번 북서풍 - Platinum 4</title>
      <link href="https://thirdsense3.github.io/acmicpc-Num_5419" rel="alternate" type="text/html" title="5419번 북서풍 - Platinum 4" />
      <published>2020-06-15T19:14:00+00:00</published>
      <updated>2020-06-15T19:14:00+00:00</updated>
      <id>https://thirdsense3.github.io/acmicpc-Num_5419</id>
      <content type="html" xml:base="https://thirdsense3.github.io/acmicpc-Num_5419">&lt;h2 id=&quot;북서풍-5419번&quot;&gt;북서풍 5419번&lt;/h2&gt;

&lt;p&gt;’’’
시간 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1초&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
메모리 제한
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;256MB&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Problem
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;강한 북서풍이 불고 있다. 이 뜻은 동쪽과 남쪽 사이의 모든 방향으로 항해할 수 있다는 뜻이다. &lt;strong&gt;북쪽이나 서쪽으로 항해하는 것은 불가능하다.&lt;/strong&gt;
작은 섬이 여러 개 있는 바다가 있다. 섬은 좌표 평면의 한 점으로 나타낼 수 있다. y 좌표가 증가하는 방향은 북쪽, x좌표가 증가하는 방향은 동쪽이다. 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 구하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Input
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;첫째 줄에 테스트 케이스의 개수가 주어진다.
각 테스트 케이스의 첫째 줄에는 섬의 수 n (1 ≤ n ≤ 75000)이 주어진다. 다음 n개 줄에는 각 섬의 좌표 x_i, y_i가 주어진다. 두 섬의 좌표가 같은 경우는 없다. (-10^9 ≤ x_i, y_i ≤ 10^9)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;’’’
Output
‘’’&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;각 테스트 케이스에 대해서, 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 먼저 생각했던 것은 항해는 동쪽과 남쪽으로만 항해가 가능하므로, x의 크기는 증가, y의 크기는 감소해야 한다고 생각했다.&lt;/p&gt;

&lt;p&gt;그런데 x,y의 좌표가 -10^9 ~ 10^9까지 가능하므로 x,y의 값을 전부 좌표로 표현한다음에 세그먼트 트리 기법이나 브루트 포스 기법은 메모리 초과 및 시간 초과가 분명했다.&lt;/p&gt;

&lt;p&gt;그래서 입력받은 섬의 x, y 좌표 값을 x좌표를 기준으로 정렬한 다음에, y좌표를 좌표압축 기법을 사용해 상대적인 값으로 나타내고 이를 이용해서 세그먼트 트리 기법을 이용하기로 했다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cstring&amp;gt;
#define MAX_N 100000

using namespace std;

pair&amp;lt;int, int&amp;gt; home[MAX_N + 1];
int n;
int total;
long long s, d;
int x, y;
int segment[4 * MAX_N]; // y의 좌표를 세그먼트 트리의 인덱스로 만듬
int y_index[MAX_N];

bool cmp(pair&amp;lt;int, int&amp;gt; x, pair&amp;lt;int, int&amp;gt; y) {
	if (x.first == y.first) {
		return x.second &amp;gt; y.second;
	}

	return x.first &amp;lt; y.first;
}

int update(int pos, int val, int node, int x, int y) { // x ~ y 인덱스까지의 세그먼트 트리 인덱스값 업데이트

	if (y &amp;lt; pos || pos &amp;lt; x) { // 범위를 벗어났을 경우, 노드 값 그대로 반환
		return segment[node];
	}

	if (x == y) { // 리프 노드인 경우, 해당 세그먼트 값 업데이트
		return segment[node] = val;
	}

	int mid = (x + y) &amp;gt;&amp;gt; 1; // 자식 tree size 정의 (산술시프트 이용)

	return segment[node] = update(pos, val, node * 2, x, mid) + update(pos, val, node * 2 + 1, mid + 1, y); // 왼쪽 자식 트리 업데이트 값 + 오른쪽 자식 트리 업데이트 값
	// 왼쪽 자식의 경우, 인덱스는 부모 인덱스 * 2, x는 부모 x값, y는 mid값
    // 오른쪽 자식의 경우, 인덱스는 부모 인데스 * 2 + 1, x값은 mid+1, y는 부모 y값
}

int query(int from, int to, int node, int x, int y) { //  x ~ y 인덱스까지의 노드 쿼리, from ~ to 까지의 인덱스 검색

	if (y &amp;lt; from || to &amp;lt; x) { // x ~ y가 찾으려는 범위를 벗어났으면 0 반환
		return 0;
	}

	if (from &amp;lt;= x &amp;amp;&amp;amp; y &amp;lt;= to) { // x ~ y가 찾으려는 범위 내면 세그먼트에 저장된 값 반환
		return segment[node];
	}

	int mid = (x + y) &amp;gt;&amp;gt; 1; // 자식 tree size 정의 (산술시프트 이용)

	return query(from, to, node * 2, x, mid) + query(from, to, node * 2 + 1, mid + 1, y); // 왼쪽 자식 쿼리 + 오른쪽 자식 쿼리
	// 왼쪽 자식의 경우, 인덱스는 부모 인덱스 * 2, x는 부모 x값, y는 mid값
	// 오른쪽 자식의 경우, 인덱스는 부모 인덱스 * 2 + 1, x값은 mid+1, y는 부모 y값
}


int main(void) {

	scanf(&amp;quot;%d&amp;quot;, &amp;amp;total);

	for (int i = 0; i &amp;lt; total; i++) {

		memset(segment, 0, sizeof(segment));
		memset(y_index, 0, sizeof(y_index));

		long long cnt = 0;

		scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

		vector&amp;lt;int&amp;gt; ypos;

		for (int j = 0; j &amp;lt; n; j++) {
			scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;s, &amp;amp;d);
			home[j] = { s,d };
			ypos.push_back(d);
		}

		sort(home, home + n, cmp);
		sort(ypos.begin(), ypos.end());
		ypos.erase(unique(ypos.begin(), ypos.end()), ypos.end()); // 좌표 압축을 위한 중복 값 제거


		for (int j = 0; j &amp;lt; n; j++) {
			int invert_y = lower_bound(ypos.begin(), ypos.end(), home[j].second) - ypos.begin(); // z는 지금 위치한 섬의 y좌표 압축 결과 인덱스
			cnt += (long long) query(invert_y, n - 1, 1, 0, n - 1); // 쿼리는 지금 위치한 섬으로 올 수 있는 섬들의 갯수를 반환 ---! n-1이 아니라 invert_y가 가질 수 있는 최대 값을 넣어도 가능 !---
			y_index[invert_y]++; // 압축한 y 인덱스 해당 좌표의 섬 갯수 증가
			update(invert_y, y_index[invert_y], 1, 0, n - 1); // 세그먼트 트리 값 업데이트
		}

		printf(&amp;quot;%lld\n&amp;quot;, cnt);

	}

	return 0;

}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Thirdsense3/3c8502d1cbaa0ff4bc0ad1705fe9dc2e.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>Seokhyun Myung</name>
        
        
      </author>

      

      
        <category term="acmicpc" />
      

      
        <summary type="html">북서풍 5419번</summary>
      

      
      
    </entry>
  
</feed>
